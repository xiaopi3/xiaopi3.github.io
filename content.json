[{"title":"Git常用操作","date":"2020-03-23T11:24:15.685Z","path":"archives/b8d84677.html","text":"Git工作流中有三个重要点： Remote远程仓库，是push的目的地 Repository本地仓库，是commit目的地 workspace工作区，是当前编辑区 Git初始化# 1. 在github上创建项目仓库 # 2. 配置本地git git config --global user.name &quot;你的名字或昵称&quot; git config --global user.email &quot;你的邮箱&quot; # 3. 初始化本地仓库-提交-链接远程仓库 git init git add . git commit -m &quot;first commit&quot; （first commit 本次提交的内容） git remote add origin &lt;your project git url&gt; git push -u origin master git push Git配置git配置基本上都在config配置文件中 配置级别从顶层到底层： system global local 系统 用户 当前仓库 底层配置会覆盖顶层配置 # 查看系统配置 git config --system --list # 查看用户配置 git config --global --list # 查看当前仓库的配置 git config --local --list 可以通过命令来查看当前git的所有配置 # 检查当前config所有配置 git config --list git初始化配置用户信息 git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx&quot; init使用git init用于初始化本地仓库，一般流程为 git init git add . git commit -m &quot;initial commit&quot; clone使用git clone将远程仓库拉下来，一般流程为 # 将代码拉下来放在当前目录中 git clone xxx链接 # 将代码拉下来放到指定目录中 git cloen xxx链接 xxx目录 commit提交跟踪文件的改动，会将改动提交到当前所在的分支上，一般流程为 git add . git commit -m &quot;comment&quot; # 使用-a参数免去add操作，直接提交tracked文件，但是没有tracked的文件不会提交 git commit -a &quot;comment&quot; branch用于查看分支，新建分支和修改分支 # 查看所有分支 git branch -a # 新建本地分支 git branch xxx # 修改本地分支名 git branch -m oldxxx newxxx push用于将本地暂存区推送到远程、修改远程分支等操作 # 推送分支 git push origin 本地名:远程名 # 如果推送到远程同名分支可以简写，不存在会被创建 git push origin xxx # 删除远程某个分支（本地空分支推送） git push origin :远程名 # 等同于 git push origin --delete 远程名 # 将当前分支推送到远程origin主机对应分支 git push origin # 可以通过-u指定远程主机，这样之后就不用指定origin git push -u origin 分支名 # 若远程主机被-u指定后，可以简写 git push checkoutgit checkout命令用于切换分支或恢复工作树文件。git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。 从分支中迁出一个分支的HEAD版本： git branch -a git checkout 分支名 merge合并两个或者多个分支的内容，一般流程 # 将xxx合并到本分支，并自动提交合并分支 git merge xxx log查看提交记录 # 查看提交日志，以下三种都可以 git log # 详细 git log --pretty=oneline # 简单 git reflog # 操作记录 # 回滚本地记录 git reset --hard xxxid # 回滚远程记录 git push -f [origin xxx] resetgit reset命令用于将当前分支的HEAD复位到指定状态。一般用于撤消之前的一些操作(如：git add,git commit等)。该命令不会改变工作区的内容！ HEAD表示当前分支最新的提交 git reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD] 将当前分支重置到指定commit，默认为HEAD –hard从commit之后的任何改动都被丢弃，并将HEAD指向commit # 第一次提交：add test1.c # 第二次提交：add test2.c # 第三次提交：add test3.c ---&gt; HEAD # 将HEAD往过去挪一步：此时抛弃了test3.c，只保留了前两个，但是不改变工作区内容 git reset --hard HEAD~1 # 撤销最近一次commit，将其挪回工作区 git reset head~1 rebase用于将一个分支的修改，合并到当前分支 应用场景使用情形：同一个分支上，A和B都做了commit，其中一个人做了push，另一个人push时就会失败 此时几种办法： pull：直接拉取会出现冲突，解决冲突后可以提交，等价于merge merge：将远端代码拉下来与本地代码merge，然后解决冲突，再add、commit、push rebase：将当前的commit存为patch，然后拉取最新代码，然后自动合并 图解： origin和mywork在C2的基础上往右前进两个commit： 如果采用merge，此时工作流为： 如果采用rebase，将改动放置到临时区，然后拉取最新代码，然后合并： 其他操作git status查看当前项目的跟踪情况 git diff比较工作区和暂存区文件差异 git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff git diff &lt;id1&gt; &lt;id2&gt; # 比较两次提交之间的差异 git diff &lt;branch1&gt; &lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异 git diff --cached # 比较暂存区和版本库差异 git diff --stat # 仅仅比较统计信息 git remote# 去除本地缓存的远程主机不存在的分支 git remote prune origin # 将本地仓库关联远程仓库 git remote add origin xxxurl git-keygen生成ssh密钥，设置好用户名和邮箱后 ssh-keygen -t rsa -C &quot;邮箱&quot; 连续三个回车即可，将生成的两个文件中的pub后缀的拷贝到github ssh设置中即可 典型应用场景1.新建本地分支，修改代码，提交到远程同名分支# 切换到基础分支 git checkout abc # 在该分支上进行coding，结束 # 查看所有分支 git branch -a # 新建本地分支 git branch xxx # 切换到分支 git checkout xxx # 提交修改到暂存区 git add . git commit -m &quot;xxx&quot; # 提交代码到远程分支 git push origin abc 2.重命名本地分支，删除远程分支，并提交到远程# 查看当前分支 git branch -a # 重命名原来本地分支 git branch -m oldxxx newxxx # 切换到分支 git checkout xxx # 提交修改到暂存区 git add . git commit -m &quot;xxx&quot; # 删除远程原来分支 git push origin --delete oldxxx # 提交代码到远程分支 git push origin newxxx –delete可以写成-d 3.重置本地仓库有时候我会把本地的代码彻底搞乱，因此需要放弃本地修改，选择从远端仓库拉取代码覆盖，具体操作如下 git fetch --all git reset --hard origin/[branch-name] git pull 4.拉取远程最新分支，并与本地分支合并由于某个分支上有人push了最新的代码，我们在push代码时如果需要防止与其冲突或者某个分支新增了功能，我们当前分支需要使用，则需要将其分支与我们的进行合并 # 切换到分支a git checkout a # 将a分支最新代码拉下来 git pull # 切换回分支b git checkout b # 合并 git merge a # 推送合并分支到b git push 5.报错内容出现upstream branch与current branch不匹配git push -u origin currentxxx","tags":[{"name":"git","slug":"git","permalink":"https://xiaopi3.gitee.io/tags/git/"}]},{"title":"webpack4.0快速上手","date":"2020-03-21T12:38:05.000Z","path":"archives/dae84e08.html","text":"webpack常用来处理前端工程化问题：包括自动化打包、es6转换、图片处理、css样式压缩等 [toc] 一、webpack快速上手之基础篇安装webpack两种方式：全局和本地 全局安装npm intall -g webpack webpack-cli // or yarn global add webpack webpack-cli 使用： 使用webpack对文件进行编译，如当前目录存在index.js文件： webpack index.js // or webpack index.js --mode development // or webpack index.js --mode production 注意：webpack默认查找路径为项目根路径下的src 本地安装全局安装模式下，当项目放到其他环境时无法通过npm install安装项目所需依赖，因为依赖在全局环境中，没有写入package.json文件中 本地安装解决以上问题 // 初始化package.json npm init -y // 安装webpack yarn add -D webpack webpack-cli 修改package.json文件： &quot;scripts&quot;:{ &quot;build&quot;:&quot;webpack&quot; } 项目目录：web01/src/index.js 启动打包 yarn build // or npm run build 注意：此时会有提示没有设置mode，可以在package.json中设置，也可以单独配置（配置文件中的mode字段） &quot;scripts&quot;:{ &quot;build&quot;:&quot;webpack --mode production&quot; } 配置webpack需求引入：不光是main.js，如果需要连同html一起生成，则必须通过webpack的配置才行 需要生成你html文件，必须安装htmlwebpackplugin插件 npm install -D html-webpack-plugin 然后配置：web01/webpack.config.js const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;) module.exports={ entry: &quot;./src/index.js&quot;,/* 以配置文件开始 */ plugins:[ new HtmlWebpackPlugin() ] } 然后打包，即可看到index.html 一个完整的webpack.config.js包括： const path = require(&#39;path&#39;); module.exports = { mode: &quot;production&quot;, // &quot;production&quot; | &quot;development&quot; | &quot;none&quot; // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: &quot;./app/entry&quot;, // string | object | array // 这里应用程序开始执行 // webpack 开始打包 output: { // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, &quot;dist&quot;), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: &quot;bundle.js&quot;, // string // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: &quot;/assets/&quot;, // string // 输出解析文件的目录，url 相对于 HTML 页面 library: &quot;MyLibrary&quot;, // string, // 导出库(exported library)的名称 libraryTarget: &quot;umd&quot;, // 通用模块定义 // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ }, module: { // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） { test: /\\.jsx?$/, include: [ path.resolve(__dirname, &quot;app&quot;) ], exclude: [ path.resolve(__dirname, &quot;app/demo-files&quot;) ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: { test, include, exclude }, // issuer 条件（导入源） enforce: &quot;pre&quot;, enforce: &quot;post&quot;, // 标识应用这些规则，即使规则覆盖（高级选项） loader: &quot;babel-loader&quot;, // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: { presets: [&quot;es2015&quot;] }, // loader 的可选项 }, { test: /\\.html$/, test: &quot;\\.html$&quot; use: [ // 应用多个 loader 和选项 &quot;htmllint-loader&quot;, { loader: &quot;html-loader&quot;, options: { /* ... */ } } ] }, { oneOf: [ /* rules */ ] }, // 只使用这些嵌套规则之一 { rules: [ /* rules */ ] }, // 使用所有这些嵌套规则（合并可用条件） { resource: { and: [ /* 条件 */ ] } }, // 仅当所有条件都匹配时才匹配 { resource: { or: [ /* 条件 */ ] } }, { resource: [ /* 条件 */ ] }, // 任意条件匹配时匹配（默认为数组） { resource: { not: /* 条件 */ } } // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ }, resolve: { // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ &quot;node_modules&quot;, path.resolve(__dirname, &quot;app&quot;) ], // 用于查找模块的目录 extensions: [&quot;.js&quot;, &quot;.json&quot;, &quot;.jsx&quot;, &quot;.css&quot;], // 使用的扩展名 alias: { // 模块别名列表 &quot;module&quot;: &quot;new-module&quot;, // 起别名：&quot;module&quot; -&gt; &quot;new-module&quot; 和 &quot;module/path/file&quot; -&gt; &quot;new-module/path/file&quot; &quot;only-module$&quot;: &quot;new-module&quot;, // 起别名 &quot;only-module&quot; -&gt; &quot;new-module&quot;，但不匹配 &quot;only-module/path/file&quot; -&gt; &quot;new-module/path/file&quot; &quot;module&quot;: path.resolve(__dirname, &quot;app/third/module.js&quot;), // 起别名 &quot;module&quot; -&gt; &quot;./app/third/module.js&quot; 和 &quot;module/file&quot; 会导致错误 // 模块别名相对于当前上下文导入 }, /* 可供选择的别名语法（点击展示） */ /* 高级解析选项（点击展示） */ }, performance: { hints: &quot;warning&quot;, // 枚举 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) { // 提供资源文件名的断言函数 return assetFilename.endsWith(&#39;.css&#39;) || assetFilename.endsWith(&#39;.js&#39;); } }, devtool: &quot;source-map&quot;, // enum // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map&#39; 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: &quot;web&quot;, // 枚举 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [&quot;react&quot;, /^@angular\\//], // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: &quot;errors-only&quot;, // 精确控制要显示的 bundle 信息 devServer: { proxy: { // proxy URLs to backend development server &#39;/api&#39;: &#39;http://localhost:3000&#39; }, contentBase: path.join(__dirname, &#39;public&#39;), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... }, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */} https://www.webpackjs.com/configuration/ Entry入口文件，可以是单一入口，和多入口：string，array，object 多入口可以拆分代码将每个页面需要的js分离出来，使用对象作为entry时可以规定输出文件的名字！ // 可以是如下值 entry: &quot;./app/entry&quot;, entry: [&quot;./app/entry1&quot;, &quot;./app/entry2&quot;], entry: { a: &quot;./app/entry-a&quot;, b: [&quot;./app/entry-b1&quot;, &quot;./app/entry-b2&quot;] }, Output指定输出文件的名字和其他属性 output: { // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, &quot;dist&quot;), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: &quot;bundle.js&quot;, // string filename: &quot;[name]xxx.js&quot;, // 用于多个入口点(entry point)（按照entry定义的名字输出） filename: &quot;[chunkhash].js&quot;, // 用于长效缓存 // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: &quot;/assets/&quot;, // string publicPath: &quot;&quot;, publicPath: &quot;https://cdn.example.com/&quot;, // 输出解析文件的目录，url 相对于 HTML 页面 library: &quot;MyLibrary&quot;, // string, // 导出库(exported library)的名称 libraryTarget: &quot;umd&quot;, // 通用模块定义，或： // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ }, filename: &quot;[hash:4].js指定4位哈希码，可以解决浏览器缓存不更新文件的情况，如果改变文件内容（此处hash会将entry中入口的文件组合在一起hash），会导致编译出来的hash码不相同，同一次编码出来的hash相同。 path字段要求必须是绝对路径，所以可以引入node的path模块： const path = require(&quot;path&quot;) module.exports = { entry:{...}, output:{ filename:xxxx, path:path.join(__dirname,&#39;output&#39;) } } 此处path.join(__dirname,&#39;output&#39;)相当于将输出放在根目录下的output文件夹中 publicPath字段：在开发时有可能使用本地路径的图片，而生产环境中可能需要使用cdn加速来获取图片，该字段可以在编译输出文件时自动替换url","tags":[{"name":"webpack","slug":"webpack","permalink":"https://xiaopi3.gitee.io/tags/webpack/"}]},{"title":"RestTemplate快速开始","date":"2020-03-19T14:09:09.000Z","path":"archives/b7ae5eb6.html","text":"快速开始在发送url请求时，使用该工具方便将获取的请求进行映射之类的操作，参数全部放在map对象中，使用HashMap进行封装 xxx xx = restTemplate.getForObject(url,xxx.class[,params]) xxx xx = restTemplate.postForObject(url,xxx.class[,data]) HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;,id); String json = restTemplate.postForObject(&quot;http://abc.com/query&quot;,String.class,map) // 返回json字符串 参考资料： https://blog.csdn.net/itguangit/article/details/78825505","tags":[{"name":"Java","slug":"Java","permalink":"https://xiaopi3.gitee.io/tags/Java/"}]},{"title":"GsonQuickStart","date":"2020-03-19T12:53:33.000Z","path":"archives/c9248ef0.html","text":"Gson 快速开始！Gson是谷歌搞出来的用来解析json的工具，运用了java的反射机制，他的功能主要有： 将java对象解析成json对象 将json对象解析成java对象 使用时需要在maven工程中导入相应依赖 &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt; or compile &#39;com.google.code.gson:gson:2.3.1&#39; 解析解析情况分为三种： 标量（Scalar)，也就是单纯的字符串或则数字形式 序列（Sequence)，也就是若干数据按照一定顺序并列在一起又称“数组” 映射（Mapping)，也就是key/value键值对 JsonObject对象将一个json串解析成一个JsonObject对象，对于获取其中一些简单的属性比较方便，免去了写映射类了 // json：{&quot;tasks&quot;:[{&quot;id&quot;:&quot;123&quot;,&quot;name&quot;,&quot;pp&quot;},{&quot;id&quot;:&quot;456&quot;,&quot;name&quot;,&quot;mm&quot;}]} JsonObject workInfoObj = gson.fromJson(workInfoObjStr,JsonObject.class); String workTaskId = workInfoObj.get(&quot;tasks&quot;).getAsJsonArray().get(0).getAsJsonObject().get(&quot;id&quot;).getAsString(); JsonObject方法详情查看：https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/JsonObject.html 普通对象采用映射方式，将JavaBean对象的属性值与json对象进行映射，注意：不匹配的属性不会被映射，字段值必须一样！ String json_str = &quot;{&quot;name&quot;:&quot;kalen&quot;, &quot;age&quot;:22}&quot;; Gson gson = new Gson(); User user = gson.fromGson(json_str, User.class); 数组对象//数组对应gson中的类型 Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType(); //gson需要的转换对象或则数据来源 List&lt;String&gt; target = new LinkedList&lt;String&gt;(); target.add(&quot;blah&quot;); Gson gson = new Gson(); // 将list对象转为json对象 String json = gson.toJson(target, listType); // 将json对象转为list对象 List&lt;String&gt; target2 = gson.fromJson(json, listType); 此处使用了泛型！ 注意：当解析非基本数据类型和数组时，需要加上泛型！ Gson gson = new Gson(); String jsonArray = &quot;[\\&quot;Android\\&quot;,\\&quot;Java\\&quot;,\\&quot;PHP\\&quot;]&quot;; String[] strings = gson.fromJson(jsonArray, String[].class); 但对于List将上面的代码中的 String[].class 直接改为 List.class 是行不通的。对于Java来说List 和List 这俩个的字节码文件只一个那就是List.class，这是Java泛型使用时要注意的问题 泛型擦除。 为了解决的上面的问题，Gson为我们提供了TypeToken来实现对泛型的支持，所以当我们希望使用将以上的数据解析为List时需要这样写。 Gson gson = new Gson(); String jsonArray = &quot;[\\&quot;Android\\&quot;,\\&quot;Java\\&quot;,\\&quot;PHP\\&quot;]&quot;; String[] strings = gson.fromJson(jsonArray, String[].class); List&lt;String&gt; stringList = gson.fromJson(jsonArray, new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType()); 注：TypeToken的构造方法是protected修饰的,所以上面才会写成new TypeToken&gt;() {}.getType() 而不是 new TypeToken&gt;().getType() 泛型解析对接口POJO的设计影响 泛型的引入可以减少无关的代码，如我现在所在公司接口返回的数据分为两类： {&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:{}} {&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:[]} 我们真正需要的data所包含的数据，而code只使用一次，message则几乎不用。如果Gson不支持泛型或不知道Gson支持泛型的同学一定会这么定义POJO。 public class UserResponse { public int code; public String message; public User data; } 当其它接口的时候又重新定义一个XXResponse将data的类型改成XX，很明显code，和message被重复定义了多次，通过泛型的话我们可以将code和message字段抽取到一个Result的类中，这样我们只需要编写data字段所对应的POJO即可，更专注于我们的业务逻辑。如： public class Result&lt;T&gt; { public int code; public String message; public T data; } // 使用 // 不再重复定义Result类 Type userType = new TypeToken&lt;Result&lt;User&gt;&gt;(){}.getType(); Result&lt;User&gt; userResult = gson.fromJson(json,userType); User user = userResult.data; Type userListType = new TypeToken&lt;Result&lt;List&lt;User&gt;&gt;&gt;(){}.getType(); Result&lt;List&lt;User&gt;&gt; userListResult = gson.fromJson(json,userListType); List&lt;User&gt; users = userListResult.data; 那么对于data字段是User时则可以写为 Result ,当是个列表的时候为 Result&gt;，其它同理。 对于泛型封装可以参考： 《搞定Gson泛型封装》 自定义解析由于js和java的命名方式不同，如js采用下划线_连接命名而java采用驼峰命名，此时前后端的字段无法对应，导致映射失败，可以采用自定义解析方式，规定规则，或者采用注解方式。 GsonBuilder定制gson实例对象中的解析方式 Gson gson = new GsonBuilder() .registerTypeAdapter(Id.class, new IdTypeAdapter()) .enableComplexMapKeySerialization() .serializeNulls() .setDateFormat(DateFormat.LONG) .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)//会把字段首字母大写 .setPrettyPrinting() .setVersion(1.0) .create(); 此处我们关注setFieldNamingPolicy方法即可，传入解析命名规则： Enum Constant Description IDENTITY 原样解析 LOWER_CASE_WITH_DASHES 将Java驼峰规则转换为小写用 - 连接的字段来映射 LOWER_CASE_WITH_DOTS 将Java驼峰规则转换为小写用 . 连接的字段来映射 LOWER_CASE_WITH_UNDERSCORES 将Java驼峰规则转换为小写用 _ 连接的字段来映射 UPPER_CAMEL_CASE 将Java驼峰规则转换为首字母也大写的规则 UPPER_CAMEL_CASE_WITH_SPACES 将Java驼峰规则转换为首字母也大写，且使用空格分割 其余属性均可在该网站查询到： setFieldNamingPolicy 设置序列字段的命名策略(UPPER_CAMEL_CASE,UPPER_CAMEL_CASE_WITH_SPACES,LOWER_CASE_WITH_UNDERSCORES,LOWER_CASE_WITH_DASHES) addDeserializationExclusionStrategy 设置反序列化时字段采用策略ExclusionStrategy，如反序列化时不要某字段，当然可以采用@Expore代替。 excludeFieldsWithoutExposeAnnotation 设置没有@Expore则不序列化和反序列化 addSerializationExclusionStrategy 设置序列化时字段采用策略，如序列化时不要某字段，当然可以采用@Expore代替。 registerTypeAdapter 为某特定对象设置固定的序列和反序列方式，实现JsonSerializer和JsonDeserializer接口 setFieldNamingStrategy 设置字段序列和反序列时名称显示，也可以通过@Serializer代替 setPrettyPrinting 设置gson转换后的字符串为一个比较好看的字符串 setDateFormat 设置默认Date解析时对应的format格式 @Expose注解如果采用new Gson()方式创建Gson则@Expose则没有任何效果，若采用GsonBuilder创建Gson并且调用了excludeFieldsWithoutExposeAnnotation则@Expose将会影响toJson和fromGson序列化和反序列化数据。 public class User { @Expose private String firstName; @Expose(serialize = false) private String lastName; @Expose(serialize = false, deserialize = false) private String emailAddress; private String password; } 例子中password不管是toJson还是fromJson都不会用到，emailAddress和lastName在序列化(fromJson)时将被采用，emailAddress在反序列化（toJson）时将不被采用。 @SerializedName注解该注解标注在JavaBean的字段上，用于候选对应解析的字段 @SerializedName 注解解决 JSON 字符串键名称和 POJO 类属性名不对应的问题 // 如果json字符串为 String jsonStr=&quot;{&#39;my_name&#39;:&#39;pp&#39;}&quot;; // JavaBean中name字段为 @SerializedName(&quot;my_name&quot;) private String myName; SerializedName注解提供了两个属性，上面用到了其中一个，别外还有一个属性alternate，接收一个String数组。注：alternate需要2.4版本 @SerializedName(value = &quot;emailAddress&quot;, alternate = {&quot;email&quot;, &quot;email_address&quot;}) public String emailAddress; 注意：当上面的三个属性(email_address、email、emailAddress)都中出现任意一个时均可以得到正确的结果。注：当多种情况同时出时，以最后一个出现的值为准。 解析复杂对象参考：https://www.jianshu.com/p/185e1ee9f05b 本文参考资料： https://www.jianshu.com/p/31396863d1aa https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/FieldNamingPolicy.html https://www.jianshu.com/p/558844c96fc1 https://github.com/google/gson/blob/master/UserGuide.md https://www.jianshu.com/p/e740196225a4","tags":[{"name":"Java","slug":"Java","permalink":"https://xiaopi3.gitee.io/tags/Java/"}]},{"title":"ESLint学习笔记","date":"2020-03-16T02:41:43.000Z","path":"archives/d70b794b.html","text":"一、安装并使用Eslint本地项目安装： // 放在开发依赖中 npm install eslint -D向导配置： npx eslint --init运行eslint检测： npx eslint xxx.js // 可以使用通配符 npx eslint ./src/*.js 为了方便，可以在packages.json中配置执行脚本 &quot;scripts&quot;:{ &quot;eslint&quot;:&quot;eslint ./src/*.js&quot; } // 在命令行中，执行该命令 yarn eslint 注意：eslint ./src/.js只检测src下的js文件，不进入目录，若想检测src下*所有文件和目录里的文件**： &quot;scripts&quot;:{ &quot;eslint&quot;:&quot;eslint src&quot; } console错误错误重现mkdir proj cd proj yarn init -y &amp;&amp; yarn add eslint &amp;&amp; code . 创建文件：src/index.js console.log(&quot;hello&quot;); 运行eslint配置向导。。。参考above，然后执行检测 npx eslint ./src/*.js 报错！！！ 解决由于使用了默认配置，默认配置不允许console，所以打开eslintrc.json文件，新增一条规则： &quot;rules&quot;:{ &quot;no-console&quot;:&quot;off&quot; } 二、解读Eslint配置env当前eslint运行的环境，每套环境都包括一套全局变量 比如，window全局变量只在env=browser中，global全局变量只在env=node中，$()只在env=jquery中 相关规则在nodemodule中的globals里 相关变量可以查看文档 也可以通过注释指定环境：/* eslint-env node, mocha */ globals这里放的是能额外访问的全局变量 在某个页面上当使用全局变量时会检测报错：使用未定义变量 解决方法： 使用注释声明变量为全局变量：/* global xxx */ 在eslint配置文件中声明变量 &quot;globals&quot;: { &quot;xxx&quot;: &quot;readonly&quot; } readonly字段也可以为true和false（同readonly） rules制定的检测规则 在使用单个属性修改时：&quot;no-console&quot;:&quot;off&quot;这样的为修改！ 在使用[]赋值时：&quot;semi&quot;:[&quot;error&quot;,&quot;always&quot;]为覆盖！ extends设定使用的是规则样板中的哪一种，即继承哪一种，在eslint文档中，打勾的表示recommend配置 配合rules属性，可以自定义当前配置：继承extends配置，然后并修改 更详细配置：http://eslint.cn/ 三、不同目录自定义配置规则在需要作用的目录下创建.eslintrc.js文件，则eslint会在规则匹配时默认使用距离最近的规则 同时，如果package.json和eslintrc同时存在则会优先使用eslintrc 如果只有eslintrc，且与父目录中的package.json配置冲突，则会优先使用子文件中的eslintrc规则 四、在项目中配置Eslint JS配置文件 YML配置文件 JSON配置文件 package.json文件中配置 前三种使用向导进行配置即可，最后一种在package.json中添加一个字段，然后将配置文件copy过来即可： &quot;eslintConfig&quot;: { &quot;env&quot;: { ... }, ... }, &quot;eslintIgnore&quot;: [&quot;hello.js&quot;] 注意：可以使用注释为某个文件单独配置 注释格式：/* eslint no-console: &quot;off&quot; */，多个配置使用逗号分隔 如果不想检查本文件，在文件开头加上：/* eslint-disable */ 五、Eslint插件配置插件在extends字段中进行配置 六、Glob路径匹配用于按路径改写规则 如前面定义了规则，在下面加入overrides字段可以按照路径来覆盖前面的规则 &quot;rules&quot;:{ &quot;quotes&quot;:[&quot;error&quot;,&quot;double&quot;] }, &quot;overrides&quot;:[ { &quot;files&quot;:[&#39;*.test.js&#39;,&#39;test/**.js&#39;], &quot;excludeFiles&quot;:[&#39;test/*/*.js&#39;], &quot;rules&quot;:{ &quot;quotes&quot;:[&quot;error&quot;,&quot;double&quot;] } } ] 以上将结尾为.test.js的和test目录下的所有包括子目录的js引号改为双引号验证规则，这个规则不包括test目录下的子目录里的js文件 七、在提交代码时运行检测git的特性，在提交前进行处理，然后再配置文件package.json中： pre-commit插件 &quot;scripts&quot;:{ &quot;lint&quot;:&quot;eslint src&quot;, }, &quot;pre-commit&quot;:[&quot;lint&quot;] husky插件 &quot;husky&quot;:{ &quot;hooks&quot;:{ &quot;pre-commit&quot;:&quot;npm run lint&quot; } } 该插件可以在git的多个阶段来执行","tags":[{"name":"ESLint","slug":"ESLint","permalink":"https://xiaopi3.gitee.io/tags/ESLint/"}]},{"title":"npm与npx","date":"2020-03-15T08:50:50.000Z","path":"archives/a7d54fb6.html","text":"npxnpx是一个工具，npm v5.2.0引入的一条命令（npx），一个npm包执行器，旨在提高从npm注册表使用软件包的体验 ，npm使得它非常容易地安装和管理托管在注册表上的依赖项，npx使得使用CLI工具和其他托管在注册表。它大大简化了一些事情。 就像npm极大地提升了我们安装和管理包依赖的体验，在npm的基础之上，npx让npm包中的命令行工具和其他可执行文件在使用上变得更加简单。它极大地简化了我们之前使用纯粹的npm时所需要的大量步骤。 举例 使用create-react-app创建一个react项目。 npm： npm install -g create-react-app create-react-app my-app npx： npx create-react-app my-app 这条命令会临时安装 create-react-app 包，命令完成后create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。 npx 会帮你执行依赖包里的二进制文件。 举例来说，之前我们可能会写这样的命令： npm i -D webpack ./node_modules/.bin/webpack -v 如果你对 bash 比较熟，可能会写成这样： npm i -D webpack npm bin/webpack -v 有了 npx，你只需要这样： npm i -D webpack npx webpack -v 也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！ npx 甚至支持运行远程仓库的可执行文件： npx github:piuccio/cowsay hello 再比如 npx http-server 可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些） npx http-server 指定node版本来运行npm scripts： npx -p node@8 npm run build 主要特点：1、临时安装可执行依赖包，不用全局安装，不用担心长期的污染。2、可以执行依赖包中的命令，安装完成自动运行。3、自动加载node_modules中依赖包，不用指定$PATH。4、可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。 来自 http://itxw.net/article/7.html 一些简写：npm install=npm i 在git clone项目的时候，项目文件中并没有 node_modules文件夹，项目的依赖文件可能很大。直接执行，npm会根据package.json配置文件中的依赖配置下载安装。 -global=-g，全局安装，安装后的包位于系统预设目录下 –save=-S，安装的包将写入package.json里面的dependencies，dependencies：生产环境需要依赖的库 –save-dev=-D，安装的包将写入packege.json里面的devDependencies，devdependencies：只有开发环境下需要依赖的库","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xiaopi3.gitee.io/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://xiaopi3.gitee.io/tags/npm/"}]},{"title":"mobx快速入门","date":"2020-03-15T07:29:32.000Z","path":"archives/d395dd70.html","text":"mobxmobx是啥：是一个用来管理状态的库，如果被观测组件发生改变，会自动渲染有关页面，告别setState。 mbox编程的3个重点： observer观测器：带有观测器的react组件或者属性被mobx实时观测 observable可观测对象：由mobx建立的可观测对象 action更新事件：标识观测对象的改变事件 Actions：一段可以改变观测变量状态的代码，类似于setState，严格模式下，只有在动作中才可以修改状态 mobx编程的4个概念： State：状态：相当于有数据的表格 Derivations：驱动 computed value：计算值 reactions：反应 计算值和反应的区别：计算值会产生新的可观测量，反应为所有变量包括可观测变量的一系列运算，并不产生新的可观测量 computed value可以看作一个包含各种计算的变量，计算属性本质是方法，只是在使用这些计算属性的时候，把他们的名称直接当作属性来使用，并不会把计算属性当作方法去调用，不需要加小括号()调用。 此计算属性的方法内部所用到的任何data中的数据，依赖响应属性只要发生改变，就会立即重新计算，即触发这个计算属性的重新求值；否则不会重新计算求值。 计算属性的求值结果会被缓存起来，方便下次直接使用（多次调用只要内部数据不改变就不会重新求值，改变了也只会计算一次，虽然有多个地方引用此属性）。 计算属性的方法内部无论如何都要return出去一个值。 使用若使用create-react-app工具创建的工程，首先需要npm run eject，然后在package.json中输入： &quot;babel&quot;: { &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true } ] ], &quot;presets&quot;: [ &quot;react-app&quot; ] } 以支持装饰器语法。 最后需要导入的包：mobx和mobx-react，可以使用npm install mobx,mobx-react --save来导入 mobx quickstartimport React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39; import {observable,action} from &#39;mobx&#39;; import {observer} from &#39;mobx-react&#39;; var appState = observable({ timer: 0 }); appState.resetTimer = action(function reset() { appState.timer = 0; }); setInterval(action(function tick() { appState.timer += 1; }), 1000); @observer class TimerView extends React.Component { render() { return ( &lt;button onClick={this.onReset.bind(this)}&gt; Seconds passed: {this.props.appState.timer} &lt;/button&gt; ); } onReset() { this.props.appState.resetTimer(); } }; ReactDOM.render(&lt;TimerView appState={appState} /&gt;, document.body); mobx声明1. 使用函数封装：类型：Array/Object/Map： 声明：var arr = observable([1,2,3]) 取值：arr[0] 赋值：arr[0]=4 类型：其他需要使用box封装： 声明：var num = observable.box(20) 取值：num.get() 赋值：num.set(4) 注意：只会对声明observable时的已有属性进行观察，新加入的属性不会监视，需要用extendObservable()来处理 建议的最佳实践：在程序初始化时就声明出所有会被使用的属性 2. 使用修饰器修饰器只能修饰类和类属性，修饰器统一使用@observable来修饰，无需使用box 如： class Store{ @observable array=[]; @observable obj={}; @observable map=new Map(); @observable string=&#39;abc&#39;; @observable number=20; @observable bool=false; } 注意：获取和赋值都与正常一样，但是在取值时取得值是mobx的observable类型，可以使用mobx提供的toJS()方法来将该类型转换为普通的js类型。 computed前提： class Store{ @observable string=&#39;a&#39;; @observable num=12; } var store=new Store(); computed：组合观察数据形成一个新观测值，接受一个无参数的函数，必须有返回值，且使用get()方法来获取计算值 使用函数： // 注入store // 定义foo变量，表示string和num的计算值 var foo=computed(function(){return store.string+&#39;/&#39;+store.num}); // 当foo变化时调用指定的函数执行操作 foo.observe(函数) foo.observe(function(change){console.log(change);}) //可以用来观察监测值，如果有改动就调用函数 使用注解： // 若使用注解，则必须在store类中事先定义好计算值 @computed get mixed(){return store.string+&#39;/&#39;+store.num}}; // 调用autorun方法，接受一个函数，当函数内部的可观测数据变化时执行函数，此处由于没有使用mixed计算值，则string或者num变化都会输出 autorun(()=&gt;{console.log(return store.string+&#39;/&#39;+store.num);}); // 使用mixed计算值，只有该值变化才输出 autorun(()=&gt;{console.log(store.mixed);}) autorunautorun中的可观察数据如果发生改变，则自动运行一次，注意：第一次定义autorun也会运行一次，接收一个无参函数 when接收两个函数作为参数，当第一个函数返回true，就会执行一次第二个函数，且全局只执行一次，不再被触发 when(()=&gt;stroe.bool,()=&gt;console.log(&#39;it is true&#39;)); 注意：第一个函数必须根据可观察数据来计算返回值，不能是普通不可观察变量 reaction接收两个函数作为参数，第一个函数中的可观察值变化时执行第二个函数，相当于when的循环版 action该装饰器保证在其内部修改的变量会等待函数运行结束后再同时触发反应。使用方式： action(&quot;xxx&quot;,()=&gt;{…}) action 包装/装饰器只会对当前运行的函数作出反应，而不会对当前运行函数所调用的函数（不包含在当前函数之内）作出反应！ 这意味着如果 action 中存在 setTimeout、promise 的 then 或 async 语句，并且在回调函数中某些状态改变了，那么这些回调函数也应该包装在 action 中。可以使用runInAction解决。 @action：修饰的函数必须注意，如果其内部调用了非@action.bound修饰的异步回调函数，会报错，因为回调函数不在当前上下文环境中，导致this指向错误！可以使用action或者runInAction包裹代码来解决。 @action.bound：该装饰器将函数上下文绑定了，可以放在其他上下文中依然正确执行，这种写法在将方法传给callback时非常有用 var run = dStore.run run() runInAction随时定义匿名的action然后运行，接收一个无参函数 注意：在异步或者回调函数中，@action范围在仅仅在代码块，直到第一个await，如果后续还有其他的await，需要使用runInAction包裹！ observer属于mobx-react包，与react结合使用，在会调用函数导致改变mobx状态的react组件上注解 Provider属于mobx-react包，如果当前react项目需要启用mobx管理状态，则必须在根节点上使用Provider标签包裹，同时传递注入对象 在store.js中汇总所有待管理store import test from &#39;./test&#39; import mast from &#39;./mast&#39; const stores = { test, mast, } export default stores 在App.jsx中 import { Provider } from &quot;mobx-react&quot; import stores from &#39;./store&#39; import {configure} from &#39;mobx&#39;; // 开启严格模式 configure({enforceActions: true}) // 开启严格模式 class App extends Component{ render(){ return( &lt;Provider store={...store}&gt; &lt;ToDoApp/&gt; &lt;/Provider&gt; ) } } configure 代表开启了严格模式，因为非严格模式下，组件是直接可以通过props.action改变state数据的，当项目复杂的时候这样是非常危险的。所以要设置唯一改变state方式是通过action inject属于mobx-react包，对当前的react组件进行注入store，以便访问可观察值，注入的值在this.props中 @inject(&#39;todoList&#39;) class ToDoApp extends Component{ render(){ return ( &lt;div&gt; &lt;TodoListView todoList={this.props.todoList}/&gt; &lt;/div&gt; ); } } 参考示例import { observable, autorun, computed, when ,reaction, action, runInAction} from &#39;mobx&#39;; class DemoStore{ @observable age = 0; @observable name = &#39;pp&#39;; @observable number = 0; @computed get lucky(){ return this.age+this.number; } @action run(){ this.age=111; this.name=&#39;gaga&#39;; this.number=222; } @action.bound runOut(){ this.age=222; this.name=&#39;jjj&#39;; this.number=this.age+this.number; } } var dStore = new DemoStore(); autorun(()=&gt;{ console.log(&quot;autorun:&quot;+dStore.lucky) }) when(()=&gt;dStore.age&gt;18,()=&gt;{console.log(&quot;when:你可以看了&quot;+dStore.age);}) reaction(()=&gt;[dStore.age,dStore.name],()=&gt;console.log(&quot;reaction:age+name=&quot;+dStore.age+dStore.name)) dStore.name=&#39;abc&#39;; dStore.number=20; dStore.age=20; dStore.run() var runOut=dStore.runOut; runOut(); runOut(); runInAction(&#39;abc&#39;,()=&gt;{ dStore.age=9; dStore.name=&#39;qqq&#39;; dStore.number=6; })","tags":[{"name":"前端","slug":"前端","permalink":"https://xiaopi3.gitee.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"mobx","slug":"mobx","permalink":"https://xiaopi3.gitee.io/tags/mobx/"}]},{"title":"Javase基础（二）——数据类型","date":"2020-03-15T03:06:01.000Z","path":"archives/9f67ee47.html","text":"Javase基础（二）——数据类型和运算常量什么是常量：在程序执行的过程中其值不可以发生改变 常量的分类 字面值常量 5， 10 ，99 之类的 自定义常量(面向对象部分讲) final PI=3.14159 字面值常量的分类 字符串常量 用双引号括起来的内容 &quot;avadsfasdfasdf&quot; 整数常量 所有整数 小数常量 所有小数 字符常量 用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号(注意，单引号里面什么也不放是不行的) 布尔常量 较为特殊，只有true和false 空常量 null(当数组引用属于局部变量且未初始化时候) 进制概述和二,八,十六进制进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。 不同进制表现同一个数据的形式特点：进制越大，表现形式越短 二进制的数据表现形式 由0,1组成。以0b(b可以大写也可以小写)开头(JDK1.7版本可以表示二进制了) 八进制的数据表现形式 由0,1,…7组成。以0开头 十进制的数据表现形式 由0,1,…9组成。整数默认是十进制的 十六进制的数据表现形式 由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头 进制转换 任意进制到十进制的转换原理 系数：就是每一位上的数据。 基数：X进制，基数就是X。 权：在右边，从0开始编号，对应位上的编号即为该位的权。 结果：把系数*基数的权次幂相加即可。 十进制到任意进制的转换 除积倒取余法 8421码 8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。 通过8421码的方式进行二进制和十进制的相互转换 二进制到八进制的简易方式：三个二进制数为一组 二进制到十六进制的简易方式：四个二进制数为一组 源码、反码、补码原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 通过一个字节,也就是8个二进制位表示+7和-7 0(符号位) 0000111 1(符号位) 0000111 反码 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码计算机计算时候都是以补码形式运算的 正数的补码与其原码相同；负数的补码是在其反码的末位加1。 例子： 已知原码求补码 0b10110100 原 0b11001011 反//符号位不变 0b11001100 补已知补码求原 0b11101110 补 0b11101101 反 0b10010010 原变量的概述及格式变量：在程序执行的过程中，在某个范围内其值可以发生改变的量，用来不断的存放同一类型的常量，并可以重复使用 格式：数据类型 变量名 = 变量值; 基本数据类型占用字节数 boolean 1 byte 1 char 2 short 2 int 4 float 4 long 8 double 8 变量相加和常量相加的区别 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 byte b1 = 3; byte b2 = 4; byte b3 = b1 + b2; 从两方面去回答这个题 b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值 byte类型的变量在进行运算的时候,会自动类型提升为int类型 byte b4 = 3 + 4; 3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了 数据类型Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间 分类 基本数据类型 引用数据类型 其他 基本数据类型分类(4类8种) 整数型 byte 占一个字节 -128到127 short 占两个字 -2^15~2^15-1 int 占四个字节 -2^31~2^31-1 long 占八个字节 -2^63~2^63-1 浮点型 float 占四个字节 -3.403E38~3.403E38 单精度(输入浮点型数值末尾需要加上f/F) double 占八个字节-1.798E308~1.798E308 双精度（小数类型默认为double） 字符型 char 占两个字节 0~65535（char类型数据参与运算会自动提升为int） 布尔型 boolean boolean理论上是占八分之一个字节,因为一个开关就可以决定是true和false了,但是java中boolean类型没有明确指定他的大小 不参与运算 类型 整型 byte short int long 浮点 float double 布尔 boolean 字符 char 字符和字符串ASCII输出：System.out.println(&#39;a&#39;); 字符类型与整数相加为ASCII字符号加整数：System.out.println(&#39;a&#39;+1); ASCII码表，记住三个值： ‘0’ 48 ‘A’ 65 ‘a’ 97 字符串与其他类型相加等于在字符串后加上字符 System.out.println(&quot;hello&quot;+&#39;a&#39;+1); System.out.println(&#39;a&#39;+1+&quot;hello&quot;); 在有字符串参与中被称为字符串连接符 System.out.println(&quot;5+5=&quot;+5+5); System.out.println(5+5+&quot;=5+5&quot;); char数据类型char c = 97; 0到65535 Java语言中的字符char可以存储一个中文汉字。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节。 占用空间类型 字节数 数据位 默认值 范围 boolean 1 8 false [true,false] byte 1 8 0 [-128,127] char 2 16 &#39;\\u0000&#39; [0,2^16]或[&#39;\\u0000&#39;,&#39;\\uffff&#39;] short 2 16 0 [-2^15,2^15-1] int 4 32 0 [-2^31,2^31-1] float 4 32 0.0f [-3.4*10^38,-1.4*10^-45]U[1.4*10^-45,3.4*10^38] long 8 64 0 [-2^63,2^63-1] double 8 64 0.0d ...long与float的取值范围谁大谁小 进行混合运算的时候,byte,short,char不会相互转换,都会自动类型提升为int类型,其他类型进行混合运算的是小的数据类型提升为大的 byte,short,char（这三个混合运算也是转换为int） – int – long – float – double long: 8个字节 float：4个字节 IEEE754： 4个字节是32个二进制位，1位是符号位， 8位是指数位，00000000 11111111，0到255，1到254，-126到127，23位是尾数位，每个指数位减去127 结论： 它们底层的存储结构不同。 float表示的数据范围比long的范围要大 long：2^63-1 float：3.410^38 &gt; 210^38 &gt; 28^38 = 22^3^38 = 2*2^114 &gt; 2^63-1 转义字符\\f 下一页 \\b 退格 \\r 回车 \\n 换行 \\t 制表 \\uxxxx 十六进制unicode字符 \\ddd 八进制unicode字符自动类型转换byte--&gt;short--&gt;char--&gt;int--&gt;long--&gt;float--&gt;doubleboolean类型不能自动类型转换 字符串与基本类型转换XXX.parseXXX(String s) //实现将字符串类型转为任意基本类型 小数准确运算import java.math.BigDecimal; public class Test { public static void main(String[] args) { System.out.println(0.05+0.01); //0.060000000000000005 BigDecimal bd1=new BigDecimal(0.05); BigDecimal bd2=new BigDecimal(0.01); System.out.println(bd1.add(bd2)); //0.06000000000000000298372437868010820238851010799407958984375 BigDecimal bd3=new BigDecimal(&quot;0.05&quot;); BigDecimal bd4=new BigDecimal(&quot;0.01&quot;); System.out.println(bd3.add(bd4)); //0.06 } } 注意事项 作用域问题：同一个区域不能使用相同的变量名 初始化值问题：局部变量在使用之前必须赋值（方法内） 一条语句可以定义几个变量：int a,b,c…; 隐式转换 int + int 结果为int byte + int 结果为int Java中的默认转换规则：取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再运算 强制转换强制转换问题 int a = 10; byte b = 20; b = a + b; 强制转换的格式，括号不能省略 b = (byte)(a + b); (强转后的二进制都是按照补码来计算) 强制转换的注意事项：如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同（环形数值圈）而强转相当于截取，两种是不同 算术运算符算术运算符，赋值运算符，比较(关系或条件)运算符，逻辑运算符，位运算符，三目(元)运算符 +,-,*,/,%,++,– 注意事项： +号在java中有三种作用,代表正号,做加法运算,字符串的连接符 整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型 /获取的是除法操作的商，%获取的是除法操作的余数 %运算符 当左边的绝对值小于右边绝对值时,结果是左边 当左边的绝对值等于右边或是右边的倍数时,结果是0 当左边的绝对值大于右边绝对值时,结果是余数 %运算符结果的符号只和左边有关系,与右边无关 任何一个正整数%2结果不是0就是1可以用来当作切换条件 算术运算符++和– ++,–运算符的作用 自加（++）自减（–）运算 ++:自加。对原有的数据进行+1 –:自减。对原有的数据进行-1 eg: int a = 10; int b = 10; int c = 10; a = b++; //a=10,b=11 c = --a; //c=9,a=9 b = ++a; //b=10,a=10 a = c--; //a=9,c=8 eg: int x = 4; int y = (x++)+(++x)+(x*10); //x=6,y=70 eg: byte b = 10; b++; //有机制 b = b + 1; //报错，b是byte不能接收int 赋值运算符 基本的赋值运算符：= 把=右边的数据赋值给左边。 扩展的赋值运算符：+=,-=,*=,/=,%= += 把左边和右边做加法，然后赋值给左边。 eg: short s=1;s = s+1; //int赋值给short，溢出错误 short s=1;s+=1; //有机质 关系运算符==,!=,&gt;,&gt;=,&lt;,&lt;= 注意事项： 无论你的操作是简单还是复杂，结果是boolean类型。 “==”不能写成”=”。 逻辑运算符 &amp; | ^ ! &amp;&amp; || （短路运算符） 注意事项： 逻辑运算符一般用于连接boolean类型的表达式或者值。 表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。 算术表达式：a + b 比较表达式：a == b(条件表达式) &amp;逻辑与:有false则false。 |逻辑或:有true则true。 ^逻辑异或:相同为false，不同为true。 !逻辑非:非false则true，非true则false。特点：偶数个不改变本身。 短路运算区别最终结果一样。&amp;&amp;具有短路效果。左边是false，右边不执行。&amp;是无论左边是false还是true,右边都会执行，同理||和|的区别同上。开发中使用短路运算比较好，但是还是要看情况而定。 位运算符&amp; | ^ ~ &gt;&gt; &gt;&gt;&gt; &lt;&lt; &amp;:有0则0 |:有1则1 ^:相同则0，不同则1 :按位取反（求一个数x的相反数格式：X+1） 位异或运算符的特点一个数据对另一个数据位异或两次，该数本身不变。 逻辑运算符：运算布尔量 位运算符：运算数值量 可以用来实现两个数的交换 int x,y; x=x^y; y=x^y; x=x^y; &lt;&lt;：左移 左边最高位丢弃，右边补齐0，相当于×2 &gt;&gt;：右移 最高位是0，左边补齐0;最高为是1，左边补齐1，相当于÷2 &gt;&gt;&gt;：无符号右移 无论最高位是0还是1，左边补齐0 eg：最有效率的算出2 * 8的结果（2&lt;&lt;3） 三元运算符三元运算符的格式：(关系表达式) ? 表达式1 : 表达式2; max=a&gt;b?b; Boolean x=a==b?trufalse; max=a&gt;b?(a&gt;c?c):(b&gt;c?c); 键盘录入键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值03.10_Java语言基础(键盘录入的练习2)(掌握)03.11_Java语言基础(顺序结构语句)(了解) import java.util.Scanner; class LuRuDemo1 { public static void main(String[] args) { Scanner sc=new Scanner(System.in); System.out.println(&quot;请分别输入两个整数!&quot;); int x=sc.nextInt(); int y=sc.nextInt(); int max; max=(x&gt;y)? x:y; System.out.println(&quot;最大的数是&quot;+max); } } 流程控制语句：可以控制程序的执行流程。 流程控制语句的分类 顺序结构 选择结构 循环结构 执行流程： 从上往下，依次执行。 选择结构if语句。。。balabala我就不介绍了 import java.util.Scanner; class If_Else { public static void main(String[] args) { int x; Scanner sc=new Scanner(System.in); System.out.println(&quot;输入一个一百以内数字&quot;); x=sc.nextInt(); if (x&gt;100|x&lt;0) { System.out.println(&quot;成绩输入错误&quot;); }else if (x&gt;=90) { System.out.println(&quot;优&quot;); }else if (x&gt;=80) { System.out.println(&quot;良&quot;); }else if (x&gt;=70) { System.out.println(&quot;中&quot;); }else if (x&gt;=60) { System.out.println(&quot;及&quot;); }else System.out.println(&quot;差&quot;); } } switch语句： switch表达式：能自动类型提升为int的都可以作为其表达式内容，long不可以，String可以。 default一定是最后执行。 import java.util.Scanner; class Day { public static void main(String[] args) { Scanner sc=new Scanner(System.in); System.out.println(&quot;请输入1-7的一个数字&quot;); int x=sc.nextInt(); switch(x){ case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期日&quot;); break; default: System.out.println(&quot;格式错误&quot;); } } } 注意： case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 default可以省略，但是不建议 break漏写会出现一个现象：case穿透。（case 穿透和default穿透） default可以在任意位置。但是建议在最后。依然是最后执行。 switch语句的结束条件 遇到break就结束了 执行到switch的右大括号就结束了 循环结构for,while,do…while 输出10次helloworld class HelloWorld { public static void main(String[] args){ for(int i=1;i&lt;=10;i++) { System.out.println(“helloworld”); } } } 需求：在控制台输出所有的”水仙花数”，所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。举例：153就是一个水仙花数。153 = 111 + 555 + 333 = 1 + 125 + 27 = 153 class Flower { public static void main(String[] args) { int a1,a2,a3,count=0; for (int i=100;i&lt;1000 ;i++ ) { a1=i%10; //个 a2=i/10%10; //十 a3=i/100; //百 if (i==a1*a1*a1+a2*a2*a2+a3*a3*a3) { System.out.println(i); count++; } } System.out.println(count); } } 初始化语句; while(判断条件语句) { // 条件满足执行循环体，不满足退出 循环体语句; 控制条件语句; } do { // 先执行循环体，再判断条件，满足继续执行 循环体语句; 控制条件语句; }while(判断条件语句); 死循环： while(true){...} for(;;){...} 循环控制语句： break：退出循环 continue：退出本次循环 for(int x=1;x&lt;=10;x++){ if(x%3==0){ //在此处填写代码 } System.out.println(&quot;Java基础班&quot;); } // 我想在控制台输出2次:&quot;Java基础班&quot; break; // 我想在控制台输出7次:&quot;Java基础班&quot; continue; // 我想在控制台输出13次:&quot;Java基础班&quot; System.out.pintln(“Java基础班”);注意：System.out.println(&quot;*&quot;);和System.out.print(&quot;*&quot;);的区别 需求：请输出下列的形状 // * // ** // *** // **** // ***** class Day04_7 { public static void main(String[] args) { for (int i=5;i&gt;0 ;i-- ) { for (int j=i;j&gt;0 ;j-- ) { System.out.print(&quot;*&quot;); } System.out.println(); } } } 需求：在控制台输出九九乘法表。 class JiuJiuBiao { public static void main(String[] args) { for (int i=1;i&lt;=9 ;i++ ) { for (int j=1;j&lt;=i ;j++ ) { System.out.print(j+&quot;x&quot;+i+&quot;=&quot;+i*j+&#39; &#39;); } System.out.println(); } System.out.println(&quot;by pp&quot;); } } 转义字符写在字符串中的字符 &#39;\\t&#39; tab键的位置 &#39;\\r&#39; 回车 &#39;\\n&#39; 换行 &#39;\\&quot;&#39; 转意字符” &#39;\\&#39;&#39; 转意字符’return的作用 返回 其实它的作用不是结束循环的，而是结束方法的。 return和break以及continue的区别： return是结束方法（写在主方法里面时候，结束主方法，程序停止运行） break是跳出循环 continue是终止本次循环继续下次循环标号：break a；跳到a这个标号处。标号也必须是合法标识符。 方法提高代码的复用性，完成特定功能的代码块。 方法的格式(写在主方法外，类中方法外) 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } 修饰符： 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： 实际参数：就是实际参与运算的。 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。 需求：求两个数据之和的案例 public static int add(int a,int b){ return a+b; } 注意： 方法不调用不执行 方法与方法是平级关系，不能嵌套定义 方法定义的时候参数之间用逗号隔开 方法调用的时候不用再传递数据类型 如果方法有明确的返回值，一定要有return带回一个值方法重载概述和基本使用) 方法重载在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 参数列表不同： 参数个数不同 参数类型不同 参数的顺序不同(算重载,但是在开发中不用) 数组数组(容器)：为了存储同种数据类型的多个值 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。数组既可以存储基本数据类型，也可以存储引用数据类型。 数组定义格式: 数据类型[] 数组名 = new 数据类型[数组的长度]; 数组动态初始化动态初始化 只指定长度，由系统给出初始化值int[] arr = new int[5]; 静态初始化 给出初始化值，由系统决定长度 动态初始化的格式：数据类型[] 数组名 = new 数据类型[数组长度]; 初始化：整数类型：byte,short,int,long都是0； 浮点：float,double都是0.0； 布尔：false 字符：’\\u0000’ 静态初始化的格式：（不允许动静结合，有元素就不写个数） 格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}; 简化格式：数据类型[] 数组名 = {元素1,元素2,…}; 区别：上一种可以先声明，再赋值。简写形式只能声明赋值在同一行。 输出数组名称和数组元素 打印数组名：[I@19bba45a：前面[代表一维数组（[[二维），I代表int类型，后面@符号代表地址值。 注意：两个异常 ArrayIndexOutOfBoundsException:数组索引越界异常 原因：你访问了不存在的索引。 NullPointerException:空指针异常 原因：数组已经不在指向堆内存了。而你还用数组名去访问元素。 int[] arr = {1,2,3}; arr = null; System.out.println(arr[0]); 数组遍历public static void print(int[] arr) { for (int i = 0;i &lt; arr.length ;i++ ) { System.out.print(arr[i] + &quot; &quot;); } } eg：求最大值 public static int getMax(int[] arr) { int max = arr[0]; for (int i = 1;i &lt; arr.length ;i++ ) { //从数组的第二个元素开始遍历 if (max &lt; arr[i]) { //如果max记录的值小于的数组中的元素 max = arr[i]; //max记录住较大的 } } return max; } 二维数组概述 二维数组格式：int[][] arr = new int[3][2]; 注意事项： 以下格式也可以表示二维数组 1：数据类型 数组名[][] = new 数据类型[m][n]; 2：数据类型[] 数组名[] = new 数据类型[m][n]; 注意下面定义的区别 int x; int y; int x,y; int[] x; int[] y[]; int[] x,y[]; x是一维数组,y是二维数组 * 二维数组格式：`int[][] arr = new int[3][];` * 二维数组格式：`int[][] arr = {{1,2,3},{4,5},{6,7,8,9}};` 需求：二维数组遍历 外循环控制的是二维数组的长度，其实就是一维数组的个数。 内循环控制的是一维数组的长度。 int[][] arr = {{1,2,3},{4,5},{6,7,8,9}}; for (int i = 0;i &lt; arr.length ;i++ ) { //获取到每个二维数组中的一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) { //获取每个一维数组中的元素 System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); } 数据类型参数传递基本数据类型传递过程不改变原值，因为调用完会弹栈，局部变量消失。 引用数据类型传递改变原值，即使方法弹栈，堆内存数组还在，可以通过地址访问","tags":[{"name":"Java","slug":"Java","permalink":"https://xiaopi3.gitee.io/tags/Java/"}]},{"title":"Javase基础（一）——概述","date":"2020-03-15T02:28:45.000Z","path":"archives/4eea31b5.html","text":"Javase基础（一）——概述A:Java语言发展史 詹姆斯?高斯林（James Gosling）1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。 SUN(Stanford University Network，斯坦福大学网络公司) B:Java语言版本C:Java语言平台 J2SE(Java 2 Platform Standard Edition)标准版 是为开发普通桌面和商务应用程序提供的解决方案,该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发 J2ME(Java 2 Platform Micro Edition)小型版 是为开发电子消费产品和嵌入式设备提供的解决方案 J2EE(Java 2 Platform Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案,该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 Java语言特点 简单性 解释性 面向对象 高性能 分布式处理 多线程 健壮性 动态 结构中立 安全性 开源 跨平台 Java语言跨平台原理只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。 JRE和JDK的概述 A:什么是JRE 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JRE:JVM+类库。 B:什么是JDK JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JDK:JRE+JAVA的开发工具。 C:为什么JDK中包含一个JRE 开发完的程序，需要运行一下看看效果。 D:JDK,JRE,JVM的作用和关系JDK=JRE+开发工具包；JRE=JVM+核心类库 JDK的下载和安装 A:JDK的下载：官网 http://www.oracle.com B:JDK的安装 安装路径不要有中文或者特殊符号如空格等。 所有和开发相关的软件最好安装目录统一。 举例：我的JDK安装路径 D:\\develop\\Java\\jdk1.7.0_72 当提示安装JRE时，可以选择不安装。建议还是安装上。 C:验证安装是否成功 a:通过DOS命令，切换到JDK安装的bin目录下。 D:\\develop\\Java\\jdk1.7.0_72\\bin b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功 JDK安装路径下的目录解释 a:bin目录：该目录用于存放一些可执行程序。 如javac.exe（java编译器）、java.exe(java运行工具)，jar.exe(打包工具)和* javadoc.exe(文档生成工具)等。 b:db目录：db目录是一个小型的数据库。 从JDK 6.0开始，Java中引用了一个新的成员JavaDB，这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4.0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。 c:jre目录：”jre”是 Java Runtime Environment 的缩写，意为Java程序运行时环境。 此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。 d:include目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。 e:lib目录：lib是library的缩写，意为 Java 类库或库文件，是开发工具使用的归档包文件。 f:src.zip文件：src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码，通过该文件可以查看Java基础类的源代码。 path环境变量的作用及配置方式1 A:在JDK的bin目录下开发程序容易产生的问题 a:如果文件过多，不方便管理 b:删除自己写过的不需要的文件，可能不小心把JDK自带的工具给删除了 B:如何解决问题：配置path环境变量 C:配置方式 a:xp系统 右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 b:win7/win8系统 右键点击桌面计算机→选择属性→选择高级系统设置→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 方式2 A:先配置JAVA_HOME：相当于多加一级目录 B:再修改path classpath环境变量的作用目前已经不用配置该项了 path和classpath的区别 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 classpath配置的java的类文件,就是.class文件 Java开发工具 A:notepad(微软操作系统自带) B:Editplus/Notepad++ C:Eclipse D:MyEclipse 先notepad，然后Editplus，再Eclipse HelloWorld编写顺序： A:定义类 B:写main方法 C:写输出语句 D:Java程序开发运行与工作原理 E:编译和运行程序 class HelloWorld { public static void main(String[] args) { System.out.println(&quot;HelloWorld&quot;); } } HelloWorld常见问题 A:找不到文件(都演示一下，让学生看看出现的都是什么问题) a:文件扩展名隐藏导致编译失败 b:文件名写错了 B:单词拼写问题(都演示一下，让学生看看出现的都是什么问题) a:class写成Class b:String写成string c:System写成system d:main写成mian C:括号匹配问题(都演示一下，让学生看看出现的都是什么问题) a:把类体的那对大括号弄掉一个 b:把方法体的那对大括号弄掉一个 c:把输出语句的那对小括号弄掉一个 D:中英文问题(都演示一下，让学生看看出现的都是什么问题) a:提示信息：错误: 非法字符: ????的格式 注意：java编程中需要的基本上都是英文字符 Java语言的书写规范 大括号要对齐,并且成对写 左大括号前面有空格 遇到左大括号要缩进,Tab 方法和程序块之间加空行让程序看起来清晰 并排语句之间加空格,例如for语句 运算符两侧加空格 注释的分类 单行注释(// )，多行注释(/* /)，文档注释(/* */) 注释的作用 A:解释说明程序 B:帮助我们调试错误 01.21_Java语言基础(关键字的概述和使用)(掌握) 关键字 被Java语言赋予特定含义的单词都是英文小写 关键字的特点：组成关键字的字母全部小写 常见关键字 public static void class boolean int protected private等 （main不是关键字） 关键字的注意事项 goto和const作为保留字存在,目前并不使用,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 标识符 就是给类,接口,方法,变量等起名字时使用的字符序列 B:标识符的组成规则 英文大小写字母 数字字符 $和_ C:标识符注意事项 不能使用关键字 不能数字开头 命名规则见名知意 包：最好是域名倒过来,要求所有的字母小写，如：com.heima.包名 类或者接口 如果是一个单词首字母大写 如果是多个单词每个单词首字母大写(驼峰命名) 方法或者变量 如果是一个单词全部小写 如果是多个单词,从第二个单词首字母大写 常量 如果是一个单词,所有字母大写 如果是多个单词,所有的单词大写,用下划线区分每个单词 总结 第一个HelloWorld敲10遍(10遍是个概数背下来为止) class HelloWorld{ public static void main(String [] args){ System.out.println(&quot;Hello World!&quot;); } } System.out.print();和System.out.println();的区别是什么 前者是输出后没有回车换行，后者输出后回车换行 标识符的命名规则注意事项? 标识符：类名，变量名，方法名，常量类名：每个首字母大写变量名，方法名：第一个首字母小写后面首字母大写常量：每个字母都大写不同单词用下划线隔开","tags":[{"name":"Java","slug":"Java","permalink":"https://xiaopi3.gitee.io/tags/Java/"}]},{"title":"分布式服务之间的通讯-RPC实战","date":"2020-03-14T16:48:10.000Z","path":"archives/2d865e10.html","text":"前提：在会议发布后，需要提供依据会议id查询发布该会议的员工信息 provider：员工信息模块 consumer：会议模块 注意：由于是两个模块的进程间通信，所以必须实现Serializable 依据服务最佳实践http://dubbo.apache.org/zh-cn/docs/user/best-practice.html 分包建议将服务接口、服务模型、服务异常等均放在 API 包中，因为服务模型和异常也是 API 的一部分，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。 如果需要，也可以考虑在 API 包中放置一份 Spring 的引用配置，这样使用方只需在 Spring 加载过程中引用此配置即可。配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml 粒度服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。 服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。 不建议使用过于抽象的通用接口，如： Map query(Map) 这样的接口没有明确语义，会给后期维护带来不便。 序列化…… 按照普通类定义好这两个类后，需要启动注册中心：zookeeper和monitor 此时，将provider服务注册到注册中心——使用spring配置声明暴露服务 然后，让consumer订阅注册中心即可。 实现步骤一、 定义两个服务模块直接选择新建工程-maven项目，建立两个普通maven项目 导入微服务依赖： &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; lombok插件为自动生成get和set方法，需要在pojo类上注解@Data 二、提取共同的api模块此处api模块为：服务接口、服务模型、服务异常 （注意：由于每个类都可以作为provider也可以作为consumer，此处为了简化，只将user模块的pojo和service提取出来了，也可以将有可能的全部提取出来） api模块目录结构：meeting-interface-api： 三、编写各自的业务实现类 实现类中在需要调用RPC方法时，需要使用spring的自动注入功能，然后引用api包： 将本类标志为@Service，将需要注入的变量标志为@Autowired pom.xml文件中引入api的jar包 &lt;dependency&gt; &lt;groupId&gt;com.pp&lt;/groupId&gt; &lt;artifactId&gt;meeting-interface-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 下图是生产者和消费者的目录结构： 生产者类： 消费者类： 四、编写各自的注册订阅配置 建议放在resources资源目录下 生产者：provider.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 最好和服务应用名称一样！且唯一--&gt; &lt;dubbo:application name=&quot;user-service-provider&quot; /&gt; &lt;!-- 使用zookeeper广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=&quot;com.pp.service.UserService&quot; ref=&quot;userServiceImpl&quot; /&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.pp.service.impl.UserServiceImpl&quot; /&gt; &lt;/beans&gt; 消费者：consumer.xml 消费者由于引用了api包中的类，需要使用spring注入该类，需要配置自动注入功能 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.pp&quot; /&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=&quot;meeting-service-consumer&quot; /&gt; &lt;!-- 使用zookeeper广播注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.pp.service.UserService&quot; /&gt; &lt;/beans&gt; 五、启动服务 提供者启动类： public static void main( String[] args ) throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext( new String[] {&quot;classpath:provider.xml&quot;} ); context.start(); System.in.read(); // 按任意键退出 } 消费者启动类: public static void main( String[] args ) throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] {&quot;classpath:consumer.xml&quot;}); context.start(); MeetingPubService meetingPubService = context.getBean(MeetingPubService.class); MeetingPub meetingPub = meetingPubService.selectByPcode(&quot;999&quot;); System.out.println( meetingPub ); // 显示调用结果 System.in.read(); }","tags":[{"name":"RPC","slug":"RPC","permalink":"https://xiaopi3.gitee.io/tags/RPC/"}]},{"title":"npm——nodejs包管理工具","date":"2020-03-14T16:36:31.000Z","path":"archives/5c8712df.html","text":"NPM包管理工具npm是nodejs包管理工具 安装安装nodejs即可，自带npm工具，无需单独安装，安装nodejs百度一下，安装完后检查一下是否成功安装：node -v &amp;&amp; npm -v 更新全局npm到最新版本：npm install npm@latest -g npm官方文档：https://www.npmjs.cn/ npm自定义文件路径： 修改npm缓存目录和全局安装目录： D盘node目录下创建两个目录，分别是node_cache和node_global，这是用来放安装过程的缓存文件以及最终的模块配置位置，执行下面这两个命令 npm config set prefix “D:\\Program Files\\node\\node_global” npm config set cache “D:\\Program Files\\node\\node_cache” 配置npm和nodejs环境变量 变量名填：NODE_PATH变量值填：D:\\Program Files\\node\\node_modules\\;D:\\ProgramFiles\\node\\node_global\\ npm安装模块#全局安装，简写-g npm install 模块名 -g #本地安装运行时依赖包 npm install 模块名 #本地安装运行时依赖包，简写-S npm install 模块名 --save #本地一次性安装多个 npm install 模块名 模块名 #本地安装开发时依赖包，简写-D npm install 模块名 --save-dev npm更新模块#检查包是否已经过时 npm outdated #更新node模块 npm update 模块名 #更新全局node模块 npm update 模块名 -g #更新到指定版本 npm update 模块名@版本号 #更新到最新版本 npm update 模块名@latest npm卸载模块#卸载本地node模块 npm uninstall 模块名 #卸载全局模块 npm uninstall 模块名 -g npm查看模块#查看帮助命令 npm help #查看某个包对于各种包的依赖关系 npm view 模块名 dependencies #查看包的源文件地址 npm view 模块名 repository.url #查看当前模块依赖的node最低版本号 npm view 模块名 engines #查看模块的当前版本号 npm view 模块名 version #查看模块的历史版本和当前版本 npm view 模块名 versions #查看一个模块的所有信息 npm view 模块名 #查看当前已经安装的模块 npm list #限制输入的模块层级 npm list --depth=0 npm list 模块名 #查看全局的包的安装路径 npm root -g npm不常用功能#更改包内容后进行重建 npm rebuild 模块名 #访问package.json的字段文档 npm help json #查看某个模块的bugs列表界面 npm bugs 模块名 #打开某个模块的仓库界面 npm repo 模块名 #打开某个模块的文档 npm docs 模块名 #打开某个模块的主页 npm home 模块名 #清除未被使用到的模块 npm prune 注意：默认情况下，当用–save或者–save-dev安装一个模块时，npm通过脱字符(^)来限定所安装模块的主版本号，而该脱字符对于不同的版本号有不同的更新机制： ^1.2.1 代表的更新版本范围为 &gt;=1.2.1 &amp;&amp; &lt; 2.0.0 ^0.2.1 代表的更新版本范围为 &gt;=0.2.1 &amp;&amp; &lt;0.3.0 ^0.0.2 代表的更新版本范围为 0.0.2 package.json该文件配置了项目各项依赖关系，在项目初始化时使用npm install来安装所有依赖（或者yarn） 该文件必须有的属性：name 必须全小写，无空格，可以使用-和_，version格式为：x.x.x { &quot;name&quot;: &quot;my-awesome-package&quot;, &quot;version&quot;: &quot;1.0.0&quot; }创建package.json 方法一：npm init 全程手动设置 方法二：npm init –yes 全部采用默认设置 可以更改默认设置属性： &gt; npm set init.author.email &quot;wombat@npmjs.com&quot; &gt; npm set init.author.name &quot;ag_dubs&quot; &gt; npm set init.license &quot;MIT&quot; 指定依赖: dependencies 生产依赖 devDependencies 开发测试依赖 { &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;dependencies&quot;: { &quot;react-dom&quot;: &quot;^16.12.0&quot;, &quot;react&quot;: &quot;^16.12.0&quot; }, &quot;devDependencies&quot;: {}, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; }","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://xiaopi3.gitee.io/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://xiaopi3.gitee.io/tags/npm/"}]},{"title":"SpringBoot-尚硅谷笔记","date":"2020-03-14T16:35:17.000Z","path":"archives/997cd353.html","text":"一、hello world目的：简化spring开发 技术栈：spring全家桶 J2EE一站式解决方案 优点： 与主流框架集成 嵌入tomcat，直接生成jar包 starters启动器，自动配置依赖和版本管理 无需xml，开箱即用 提供准生产环境的应用监控 与云计算集成 发展过程： 单体应用：所有的都写在一个应用里，牵一发动全身 微服务：独立功能元素，动态组合，节省资源，服务耦合降低 课程学习：谷粒学院、博学谷 知识前提： Spring框架掌握 Maven掌握 IDEA掌握 环境约束： jdk1.8 maven3.x IDEA2017以上 springboot 1.5.9 release 配置maven添加配置 &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;maven.compiler.encoding&gt;utf-8&lt;/maven.compiler.encoding&gt; &lt;/properties&gt; &lt;/profile&gt; IDEA配置配置默认maven为指定maven hello world需求：浏览器发送hello请求，服务器返回处理结果 1.创建普通maven工程，无骨架2.添加maven依赖包括父工程依赖和springweb依赖，此处打包为jar &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 3.编写主程序 要掌握的注解：@SpringBootApplication。标志这是一个Springboot的应用，此时注解在主函数类外 main方法中： SpringApplication.run(main类字节码文件,args) 4.编写controller文件 要掌握的注解:@Controller。表示这个类为控制类，映射请求 要掌握的注解：@RequestMapping。表示这个方法所映射的请求 要掌握的注解：@ResponseBody。表示这个方法会返回一个值给response 细代码可以参考springboot环境配置日志 5.看效果可以直接工程中点击运行查看，然后去浏览器访问查看效果，也可以maven package打包成jar，然后： java -jar xxx 然后浏览器访问即可 细节一二 RESTAPI解释 服务器请求，处理后不是跳转页面，而是返回内容 如果某个controller类的所有mapping方法都是返回一个内容（字符串或者json），那么可以将@ResponseBody加到类上面。 要掌握的注解：@RestController。这个为：@ResponseBody+@Controller 使用spring initializer快速生成springboot项目生成项目的目录结构： 主程序已经生成好 resources文件夹： static：保存静态资源：js css images templates：存放模板引擎，默认jar包使用嵌入式tomcat，不支持jsp页面 application.properties：springboot应用配置文件，用来改变默认配置 二、springboot配置配置文件 applicatin.properties application.yml 用来改变springboot默认配置，路径：src/main/resource或者类路径/config yml配置实例： server: port: 8081 yml语法基本语法key: value注意：key和value之间严格【空格】约定！同一缩进下的kv属于同一层级 ==不能是tab，只能是空格== 注意事项： 属性值中单引号中可以转义，双引号不会转移，字符串默认不用加引号 对象表示可以用行内写法：friends: {lastname: ddd,age: 18} 数组使用横杠空格表示元素 #普通写法 pets: - cat - dog - pig #行内写法 pets: [cat,dog,pig] 配置文件注入javabean配置文件内容： person: name: abc age: 18 dog: name: gaga age: 2 lists: - abc - gaga 其中，person下的第一个层级都与javabean中的属性一一对应。 在Person类中，需要加上注解：@Component和@ConfigurationProperties(prefix=&quot;person&quot;) 要掌握的注解：@ConfigurationProperties(prefix=&quot;person&quot;)。用于将配置文件内的对应属性映射到javabean上，其中prefix表示选定的配置文件字段，默认从全局配置文件中获取值 要掌握的注解：@PropertySource(...)。用于指定配置文件路径，可以指定多个，当需要获取其他文件里的配置需要加该注解 要掌握的注解：：@Component。该注解将当前类加入容器管理，标识为spring的组件，这样才能使用第六个注解的功能 注意事项： 使用上面的注解后会提示导入配置文件注解处理器包： &lt;!--导入配置文件处理器后，配置文件中写绑定信息会有提示--&gt; 验证注入情况采用spring的测试类来查看注入情况 在test-java-包下有个测试类，包含两个注解：@RunWith(SpringRunner.class)和@SpringBootTest，在测试类中写上Person person;并注解：@Autowired，然后定义一个方法输出该字段，并给该方法注解@Test 要掌握的注解：@RunWith(SpringRunner.class)。表示当前测试类使用的测试驱动器为springrunner，当然也可以指定为junit等 要掌握的注解：@SpringBootTest。表示当前类为springboot的测试类 要掌握的注解：@Autowired。表示当前类字段自动从spring容器中注入匹配的javabean 要掌握的注解：@Test。表示当前方法为需要测试的方法，必须注解在测试类中 properties语法直接看： #由于idea默认properties使用utf-8编码， #而程序运行时默认采用ascii编码， #所以输出中文会乱码，在idea的file encoding中设置运行时转码为ascii person.last-name=abc person.age=18 person.dog.name=gaga person.dog.age=1 person.maps.k1=v1 person.map.k2=v2 要掌握的注解：@Value(&quot;${person.last-name})。该注解放在javabean类中的属性上，表示从spring容器中取出哪个值注入到当前属性中，value中也支持el表达式：@Value(&quot;#{11*2})会将22注入 注意：@ConfigurationProperties和@Value 松散绑定： 只用configurationproperties支持松散绑定 spel语法：只有Value支持，毕竟另一个是统一注入的 jsr303校验：ConfigurationProperties支持，如类上加：@Validated，字段上加：@Email，则当前字段必须为邮箱格式，Value不支持 Value注解在复杂类型封装时不支持，只能注入基本数据类型","tags":[{"name":"springboot","slug":"springboot","permalink":"https://xiaopi3.gitee.io/tags/springboot/"}]},{"title":"Hexo-Nexmon主题安装和配置流程","date":"2020-03-12T10:48:59.000Z","path":"archives/85d6a244.html","text":"1. nexmon参考网址： https://docs.nexmoe.com/ 安装cd themes # 载入主题目录 git clone https://github.com/nexmoe/hexo-theme-nexmoe.git nexmoe # 安装 cd nexmoe # 进入 Nexmoe 主题目录 npm i --save hexo-wordcount # Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) # npm install hexo-wordcount@2 --save cp -i _config.example.yml _config.yml 此处只记录踩坑点!!! 主题默认开启了字数统计，所以必须要安装插件： npm i –save hexo-wordcount 尽量使用最新版的nodejs 进入主题文件夹： cp _config.example.yml _config.yml 启用进入hexo的config配置文件，将theme值改为nexmon（和主题文件夹名一致即可） hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 打开浏览器进入： localhost:4000 配置大多数配置参考主题config文件自带注释 友情链接的页面启用友情链接后，需要在博客根目录下的source文件夹内建立py.md文件，并在文件头写入： --- title: links date: 2013/7/13 20:46:25 layout: py permalink: PY.html ---友链格式： - [![标题](https://example.com/logo.png)](https://example.com/ &quot;标题&quot;)关于我页面启用关于我页面后，需要在博客根目录下的source文件夹内建立me.md文件，然后在主题config文件中配置about页面的名字即可，此处为me 2. 坑坑比较多，这里排一下雷： 文章中引用图片格式为![avatar](xxx.jpg)，图片放在资源文件夹下，资源文件夹为md文件同级的同名文件夹，需要在hexo配置中启用assets选项 给文章添加图头，格式为： --- cover: /img/xxx.xxx coverWidth: 1200 coverHeight: 750 --- 图片放置在主题文件夹下的source目录下的img内，图片大小格式与图片一致 主题bug：tagCloud高亮没有显示，解决办法:直接把css加在index文件里面： 在 nexmoe\\layout\\_widget\\tagcloud.ejs里面，和div标签平行加上内容，最终修改结果如： &lt;% if (site.tags.length){ %&gt; &lt;div class=&quot;nexmoe-widget-wrap&quot;&gt; &lt;h3 class=&quot;nexmoe-widget-title&quot;&gt;&lt;%= __(&#39;tagcloud&#39;) %&gt;&lt;/h3&gt; &lt;div id=&quot;randomtagcloud&quot; class=&quot;nexmoe-widget tagcloud&quot;&gt; &lt;%- tagcloud() %&gt; &lt;/div&gt; &lt;% if (theme.maxTagcloud){ %&gt; &lt;script&gt; var maxTagcloud = parseInt(&lt;%= theme.maxTagcloud %&gt;); var tags_length = parseInt(&lt;%= site.tags.length %&gt;); var tags_arr = []; for(var i = 0; i &lt; tags_length; i++){ tags_arr.push(i); } tags_arr.sort(function (l, r) { return Math.random() &gt; 0.5 ? -1 : 1; }); tags_arr = tags_arr.slice(0, maxTagcloud &lt; tags_length ? tags_length - maxTagcloud : 0); for(var tag_i = 0; tag_i &lt; tags_arr.length; tag_i++){ document.getElementById(&quot;randomtagcloud&quot;).children[tags_arr[tag_i]].style.display = &#39;none&#39;; } &lt;/script&gt; &lt;% } %&gt; &lt;/div&gt; &lt;style&gt; #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+1) { background-color: rgba(255,78,106,0.15); color: rgba(255,78,106,0.8); } #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+2) { background-color: rgba(255,170,115,0.15); color: #ffaa73; } #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+3) { background-color: rgba(254,212,102,0.15); color: #fed466; } #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+4) { background-color: rgba(60,220,130,0.15); color: #3cdc82; } #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+5) { background-color: rgba(100,220,240,0.15); color: #64dcf0; } #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+6) { background-color: rgba(100,185,255,0.15); color: #64b9ff; } #nexmoe-header .nexmoe-widget-wrap .tagcloud a:nth-child(7n+7) { background-color: rgba(180,180,255,0.15); color: #b4b4ff; } #nexmoe-content .nexmoe-post .nexmoe-post-meta { margin: 25px 0px; font-size: 0; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a { border-radius: 20px; padding: 10px 18px; color: #fff; font-size: 14px; display: inline-block; margin-bottom: 5px; margin-right: 10px; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a .nexmoefont { font-size: 14px; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a:before, #nexmoe-content .nexmoe-post .nexmoe-post-meta i:before { margin-right: 5px; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+1) { background-color: rgba(255,78,106,0.15); color: #ff4e6a; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+2) { background-color: rgba(255,170,115,0.15); color: #ffaa73; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+3) { background-color: rgba(254,212,102,0.15); color: #fed466; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+4) { background-color: rgba(60,220,130,0.15); color: #3cdc82; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+5) { background-color: rgba(100,220,240,0.15); color: #64dcf0; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+6) { background-color: rgba(100,185,255,0.15); color: #64b9ff; } #nexmoe-content .nexmoe-post .nexmoe-post-meta a:nth-child(7n+7) { background-color: rgba(180,180,255,0.15); color: #b4b4ff; } &lt;/style&gt; &lt;% } %&gt;","tags":[{"name":"Guide","slug":"Guide","permalink":"https://xiaopi3.gitee.io/tags/Guide/"}]},{"title":"Hexo博客框架安装教程","date":"2020-03-12T10:29:18.000Z","path":"archives/afae5a43.html","text":"安装流程 安装nodejs 安装cnpm（可选） npm install cnpm -g –registry=https://registry.npm.taobao.org 安装hexo-cli cnpm install -g hexo-cli 验证安装 hexo -v 初始化并启动 hexo init blog cd blog npm intall hexo server(或者s) 写文章 hexo n “标题” 生成并预览 hexo clean hexo g hexo s 发布到github 安装hexo-deployer-git cnpm install –save hexo-deployer-git 配置_config.yml 此处主要是与github做绑定，将本地修改的直接推送到github上。 注意：需要先在github上创建项目名为：用户名.github.io deploy: type: git repo: https://github.com/用户名/项目名 branch: master 部署到github hexo d 测试 在地址栏中输入项目名，直接进入博客 更换主题自行搜索主题进行替换，此处演示yillia主题替换： 克隆主题 git clone https://www.github.com/litten/hexo-theme-yilia.git themes/yilia 替换 hexo clean &amp;&amp; hexo d 再推荐两个主题： git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia https://github.com/nexmoe/hexo-theme-nexmoe （自用） 主题集合： https://hexo.io/themes/ 还有一个安卓风格主题： cd themes git clone https://github.com/viosey/hexo-theme-material.git material cd material git checkout {branch/tags name}注意：如果有需要，把主题文件夹内的config文件名重命名一下！去掉templete 以上三个主题全部fork到了我的gitee仓库中，提升下载速度。主题安装方式和配置参考各自主题的文档 注意此处有坑： 如果采用Gitee托管的话，进入托管的仓库-&gt;设置Gitee Pages服务，若绑定域名需要升级Gitee Pro，普通版每次更新要进行手动更新！！！具体参考：https://gitee.com/help/articles/4136 github 需要使用域名才能进行访问，我购买了xiaopi3.fun这个域名，需要在该项目的设置中的domain设置那里填入自己的域名，并启用https hexo默认解析md有可能会有奇怪的bug，需要先本地预览看看自己调一下 折叠文章使用：&lt;!--more--&gt; > 当md文件中存在： `{{ }}` or `{% %}`将会被转义导致错误，使用下面的方式来处理： > > ``` > {% raw %} > Hello {{ sensitive }} > {% endraw %}","tags":[{"name":"Guide","slug":"Guide","permalink":"https://xiaopi3.gitee.io/tags/Guide/"}]},{"title":"SpringBoot环境搭建","date":"2020-03-10T12:14:53.000Z","path":"archives/e5dfb256.html","text":"废话不多说，直接上 新建maven工程，选择空架构 在pom文件中做如下两步操作 a. 引入父工程起步依赖（所有springboot工程，都必须继承） &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; // 引入基础web起步依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; b. 新建引导类（一般习惯写在main方法中，也可以单独写） ```java /*** *spring需要一个标志来识别某个类为引导类，需要加上该注解！ */ @SpringBootApplication public class MySpringBootApplication { public static void main(String[]args) { /*** *这是一个引导类 *run方法是引导类入口，程序启动进入main方法，然后加载引导类 */ SpringApplication.run(MySpringBootApplication.class); } } 启动项目 此时无法看到页面但是项目已经正常运行起来了，为了更直观，我在这里写一个地址映射 Controller类编写 新建controller层，新建控制类，如QuickController编写一个任意方法 /*** *为了让Spring能识别，需要在这里标志为控制器 */ @Controller public class QuickController{ /*** *此方法为调用后返回字符串 *请求地址使用注解标志 *返回值类型使用注解标志 * ResponseBody标识按照Json串解析返回值 *@return字符串 */ @RequestMapping(&quot;/quick&quot;) @ResponseBody public String quick(){ return&quot;hello springboot!&quot;; } } 访问localhost:8080/quick即可看到返回值为hello Springboot! 热部署在pom.xml文件中添加依赖： &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 由于idea热部署需要配置： setting中搜索compile，将自动编译勾选 ctrl+shift+alt+/：点击第一项，自动编译勾选 快速构建项目 下载Spring Assistance插件 打开项目选择该插件，按照步骤 建立controller类 /*** *相当于Controller+ResponseBody，这样内部方法就不用再写ResponseBody了 *ResponseBody作用是将返回值按照Json字符串处理 */ @RestController public class QuickStart{ @RequestMapping(&quot;/quick2&quot;) public String quick2(){ return&quot;quick2!!!&quot;; } } } springbootapplication注解包含下面三个功能： SpringBootConfiguration：相当于Spring的Configuration注解，标注该类为配置类 EnableAutoConfiguration：启用了自动配置 ComponentScan：包扫描，默认扫描引导类同级及子级下所有的类","tags":[{"name":"springboot","slug":"springboot","permalink":"https://xiaopi3.gitee.io/tags/springboot/"}]},{"title":"Hello World","date":"2020-03-09T12:53:37.086Z","path":"archives/4a17b156.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[{"name":"测试","slug":"测试","permalink":"https://xiaopi3.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]}]